<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>3D эффект по акселерометру</title>
<style>
  :root{
    --size: 360px;
    --bg: linear-gradient(180deg,#0f172a,#071029 80%);
  }
  html,body{
    height:100%;
    margin:0;
    font-family: Inter, Roboto, "Helvetica Neue", Arial;
    background: var(--bg);
    color:#e6eef8;
    -webkit-font-smoothing:antialiased;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  /* Сцена с перспективой */
  .scene{
    width:var(--size);
    height:calc(var(--size) * 1.2);
    perspective:1000px; /* регулирует "глубину" 3D */
    position:relative;
  }

  /* Объект, который повернем по осям */
  .card{
    width:100%;
    height:100%;
    border-radius:18px;
    background: linear-gradient(160deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    box-shadow: 0 20px 40px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
    transform-style: preserve-3d;
    transition: transform 120ms linear;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    position:relative;
  }

  /* Слой заднего плана — параллакс (меньше движения) */
  .layer.bg{
    position:absolute;
    inset:0;
    transform: translateZ(-60px) scale(1.18);
    background-image: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.02), transparent 10%),
                      radial-gradient(circle at 80% 80%, rgba(255,255,255,0.02), transparent 10%);
    z-index:1;
    pointer-events:none;
  }

  /* Основное содержимое — двигается сильнее */
  .content{
    position:relative;
    z-index:3;
    text-align:center;
    transform: translateZ(30px) scale(0.95);
  }

  h1{ margin:0 0 8px 0; font-size:20px; letter-spacing:0.4px; }
  p{ margin:0; opacity:.85; font-size:13px; }

  /* Тень, которая меняет смещение и размытие */
  .shadow{
    position:absolute;
    left:50%;
    top:100%;
    width:80%;
    height:28%;
    transform:translate(-50%,-40%) rotateX(90deg);
    filter: blur(18px);
    background: radial-gradient(closest-side, rgba(2,6,23,0.65), rgba(2,6,23,0.08) 60%, transparent 100%);
    z-index:0;
    transition: all 120ms linear;
    pointer-events:none;
  }

  /* указатель/инфо */
  .controls{
    margin-top:16px;
    text-align:center;
    font-size:13px;
    opacity:.9;
  }
  .btn{
    display:inline-block;
    margin-top:8px;
    padding:8px 12px;
    border-radius:8px;
    background:rgba(255,255,255,0.06);
    color:inherit;
    text-decoration:none;
    cursor:pointer;
    border:1px solid rgba(255,255,255,0.04);
    font-size:13px;
  }

  /* маленькие устройства — уменьшить размер */
  @media (max-width:420px){
    :root{ --size:300px; }
  }
</style>
</head>
<body>
  <div style="display:flex;flex-direction:column;align-items:center;">
    <div class="scene" id="scene">
      <div class="card" id="card">
        <div class="layer bg" id="bg"></div>
        <div class="content" id="content">
          <h1>3D по акселерометру</h1>
          <p>Наклоняй устройство — смотри эффект параллакса и динамической тени</p>
        </div>
        <div class="shadow" id="shadow"></div>
      </div>
    </div>

    <div class="controls">
      <div id="status">Статус: <span id="statTxt">ожидание датчика</span></div>
      <button class="btn" id="permBtn" style="display:none">Разрешить доступ к датчикам</button>
      <div style="margin-top:8px;font-size:12px;opacity:.8">Поддержка: мобильные браузеры + fallback мышь</div>
    </div>
  </div>

<script>
/*
  Алгоритм:
   - Слушаем deviceorientation/deviceMotion (если доступны)
   - На iOS нужен вызов requestPermission() в ответ на жест пользователя
   - Если датчиков нет — используем mousemove для симуляции
   - Применяем сглаживание (low-pass filter), ограничение углов, затем mapping -> CSS transforms.
*/

const card = document.getElementById('card');
const shadow = document.getElementById('shadow');
const bgLayer = document.getElementById('bg');
const statTxt = document.getElementById('statTxt');
const permBtn = document.getElementById('permBtn');

let enabledSource = null; // "device", "mouse"
let last = { x:0, y:0, z:0 };
let smoothed = { x:0, y:0, z:0 };
const smoothing = 0.12; // 0..1  — чем меньше, тем сильнее сглаживание

// Настройки амплитуды эффектов
const MAX_TILT = 18; // градусы — максимальный вращение карты
const BG_MULT = 0.45; // фон двигается слабее
const SHADOW_SHIFT = 40; // px смещение тени при наклоне
const SHADOW_BLUR_MIN = 6;
const SHADOW_BLUR_MAX = 36;

// Преобразование углов в CSS
function applyTransform(xTiltDeg, yTiltDeg){
  // Ограничим
  const x = Math.max(-MAX_TILT, Math.min(MAX_TILT, xTiltDeg));
  const y = Math.max(-MAX_TILT, Math.min(MAX_TILT, yTiltDeg));
  // Поворачиваем карту: по X — наклон вперёд/назад, по Y — влево/вправо (знаки подобраны экспериментально)
  const rotateX = x;
  const rotateY = -y;
  card.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(0)`;

  // Параллакс фон — небольшой сдвиг
  const bgX = -y * BG_MULT;
  const bgY = -x * BG_MULT;
  bgLayer.style.transform = `translate3d(${bgX}px, ${bgY}px, -60px) scale(1.18)`;

  // Тень: сдвиг и размытие в зависимости от наклона
  const shadowX = (y / MAX_TILT) * SHADOW_SHIFT;
  const shadowY = (-x / MAX_TILT) * (SHADOW_SHIFT * 0.6);
  const blur = Math.max(SHADOW_BLUR_MIN, Math.min(SHADOW_BLUR_MAX, Math.abs(x) + Math.abs(y) + 8));
  shadow.style.transform = `translate(calc(-50% + ${shadowX}px), calc(-40% + ${shadowY}px)) rotateX(90deg)`;
  shadow.style.filter = `blur(${blur}px)`;
  // Меняем интенсивность тени (альфа) чуть-чуть
  const alpha = 0.35 + (Math.min(1, (Math.abs(x)+Math.abs(y)) / (MAX_TILT*1.6)) * 0.6);
  shadow.style.background = `radial-gradient(closest-side, rgba(2,6,23,${0.6*alpha}), rgba(2,6,23,${0.07*alpha}) 60%, transparent 100%)`;
}

// Сглаживание: экспоненциальное (low-pass)
function smoothTo(target, cur) {
  return cur + (target - cur) * smoothing;
}

// Обновление UI/параметров через requestAnimationFrame
let rafId = null;
function loop(){
  // сглаживаем
  smoothed.x = smoothTo(last.x, smoothed.x);
  smoothed.y = smoothTo(last.y, smoothed.y);
  smoothed.z = smoothTo(last.z, smoothed.z);
  applyTransform(smoothed.x, smoothed.y);
  rafId = requestAnimationFrame(loop);
}

// Обработка событий гироскопа/акселерометра
function handleDeviceOrientation(e){
  enabledSource = 'device';
  statTxt.textContent = 'используется датчик (deviceorientation)';
  // e.beta (наклон вперед/назад) : -180..180, 0 — ровно
  // e.gamma (наклон влево/вправо): -90..90
  // Нужна корректная привязка — подберём так, чтобы движение было интуитивным
  const beta = e.beta || 0; // X axis tilt
  const gamma = e.gamma || 0; // Y axis tilt

  // В некоторых устройствах оси инвертированы — можно добавить настройку, но для простоты берём beta,gamma
  // Нормализуем в диапазон градусов и уменьшим чувствительность
  last.x = (beta - 0) * 0.6; // вперед/назад
  last.y = (gamma - 0) * 0.8; // влево/вправо
}

// Для старых/других браузеров можно слушать devicemotion и интегрировать accel — пропущу для краткости

// Fallback — мышь (для десктопа)
function handleMouseMove(e){
  if (enabledSource === 'device') return; // не мешать, если устройство уже даёт данные
  enabledSource = 'mouse';
  statTxt.textContent = 'используется мышь (fallback)';
  const rect = card.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  // map to degrees
  const percentX = dy / (rect.height/2); // вверх/вниз
  const percentY = dx / (rect.width/2);  // влево/вправо
  last.x = percentX * MAX_TILT * 0.9 * -1; // инвертировать для естественного движения
  last.y = percentY * MAX_TILT * 0.9;
}

// Инициализация датчика: учитываем iOS (нужен запрос разрешения)
function initSensors(){
  // Платформенная проверка: iOS требует специального запроса
  const isiOS = typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function';
  if (isiOS){
    permBtn.style.display = 'inline-block';
    permBtn.addEventListener('click', async () => {
      try {
        const resp = await DeviceMotionEvent.requestPermission();
        if (resp === 'granted'){
          window.addEventListener('deviceorientation', handleDeviceOrientation, true);
          statTxt.textContent = 'датчики разрешены (iOS)';
          permBtn.style.display = 'none';
        } else {
          statTxt.textContent = 'доступ к датчику отклонён';
        }
      } catch (err){
        console.warn(err);
        statTxt.textContent = 'ошибка при запросе разрешения';
      }
    });
    statTxt.textContent = 'на iOS нужно нажать "Разрешить"';
    return;
  }

  // Не-iOS: добавляем слушатель, если поддерживается
  if ('ondeviceorientation' in window){
    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
    statTxt.textContent = 'ожидание данных от deviceorientation';
  } else if ('DeviceMotionEvent' in window){
    // можно слушать devicemotion (ускорения) — для простоты используем deviceorientation if available
    window.addEventListener('devicemotion', (ev) => {
      // простой mapping: gamma/ beta не всегда есть — пропускаем
    }, true);
    statTxt.textContent = 'поддерживается devicemotion, но deviceorientation недоступен';
  } else {
    statTxt.textContent = 'датчики недоступны — используем мышь';
  }
}

// стартовое поведение
function start(){
  initSensors();
  window.addEventListener('mousemove', handleMouseMove, {passive:true});
  // Запускаем loop
  if (!rafId) loop();
}

// стоп (если нужно)
function stop(){
  window.removeEventListener('deviceorientation', handleDeviceOrientation);
  window.removeEventListener('mousemove', handleMouseMove);
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
}

start();

// Доп: если хотите — можно добавить кнопку "reset" или настройки чувствительности
</script>
</body>
</html>